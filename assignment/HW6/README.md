# POSD with C++ (and more)

#### FALL, 2023

#### Prof Y C Cheng

#### Dept of Computer Science and Information Engineering

#### Taipei Tech

### Important Links

* [Course Link](http://140.124.181.100/yccheng/posd2023f): http://140.124.181.100/yccheng/posd2023f

* [Gitlab](http://140.124.181.100): http://140.124.181.100

* [Jenkins](http://140.124.181.97:8080): http://140.124.181.97:8080

## Assignment 6

### Due: Dec 27 Wed 23:59

### Notice

* **DO NOT add any .c or .cpp file in your program that is not provided or required by the assignment**
* Please use the given makefile. You can modify the makefile if needed, but do not remove "all", "dirs", and "clean". Also, "all" must depend on "dirs". If you have any further questions about makefile, please search and learn it manually.
* Do not change the code structure, function prototype, or interface of the provided code, otherwise, your code might not be compilable with TA's test.
* Do not commit the object files and executable files to git, otherwise, your code might not be executable on the Jenkins server.
* Your program should not cause memory leaks.
* The unit test you wrote will be also graded, please write the unit test comprehensively for the code you wrote.
* The design of your program will also be graded, please follow the required patterns precisely while writing your program.
* If your code is not compilable on the Jenkins server, you'll get no points for the assignment.

### Description

In this assignment, you will work based on the code from [assignment 3](./given_code). Note that the given code is slightly adjusted for this assignment. You will practice using **Abstract Factory** to use the different iterators during runtime, implementing **Template Method**, and a new pattern **Proxy**. In addition, you will experience the effort of adding a new element to an existing composite structure in a later stage of development.

### Problem

#### Refactor to use **Abstract Factory**

In this assignment, you will refactor `Node::createIterator(OrderBy)` the four different iterators with **Abstract Factory** to alter different iterators, instead of using switch cases.

1. Please complete the four implementations of `IteratorFactory` in `src/iterator_factories.h` in the given code.

2. Refactor `Node::createIterator(OrderBy)` to two overloading versions: `Node::createIterator()` and `Node::createIterator(IteratorFactory *)`; where

   * `Folder::createIterator()` returns a `FolderIterator`,
   * `Folder::createIterator(IteratorFactory *)` returns the iterator generated by the iterator factory, and
   * the other nodes return `NullIterator` for both factory methods.

3. Refactor `TreeVisitor` to accept and use `IteratorFactory` instead of `OrderBy`.

#### Implement `rename` for `Node`

Next, please add a new function `void Node::rename(std::string name)`. Please implement `rename` in the manner of **Template Method** with two steps:

   1. updating the node's path, and
   2. updating the children's paths accordingly; where the second step is a *hook operation* (refer to GoF p.328).

#### Add a new kind of leaf `Link` for `Node`

Please implement a new class `Link` under the **Composite** structure of `Node`. `Link` works as a symbolic link in a file system, i.e., it is a **Proxy** to other `Nodes`. Please refer to the **Proxy** pattern in GoF (p.207-217).

Please place the class `Link` in the path `src/link.h`. The following member functions should forward the requests to the target node (the *real subject*):

* `int numberOfFiles()`
* `Node * find(string path)`
* `std::list<string> findByName(string name)`
* `void add(Node * node)`
* `void remove(string path)`
* `Node * getChildByName(const char * name)`

In addition, please implement a public member function `Node * getTarget()` to the class `Link`. `Node * getTarget()` returns a pointer to the target node.

To make the visitor work with `Link`, please add the method `void visitLink(Link * link)` to the class `Visitor` and implement `void accept(Visitor * visitor)` for the class `Link`. In addition, you need to refactor the three existing visitors to support `Link`:

* For `FindByNameVisitor` and `StreamOutVisitor`, the method `visitLink` simply passes the request to the target node; and
* for `TreeVisitor`, a `Link` should display its own name on the output string, as a regular file.

**HINT**

1. You might need to refactor the "order by" iterators to make the traversal for `TreeVisitor` to be correct.
2. In `OrderByKind`, the kind of symbolic link is "link".
3. You can replace the "order by" iterators with your implementation. It is **NOT REQUIRED** to use the implementation in the given code, as long as they provide the same functionalities.
4. You **DON'T NEED** to support `Link` in `FileSystemParser` for this assignment.

### Score

* Design by students: 60%
* Passing Unit tests written by TA: 40%